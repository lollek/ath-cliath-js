#! /usr/bin/env python2

import pygame
from pygame.locals import *

import math
import textwrap
import shelve
import re
import os
import sys
import random

from ath_cliath.Tile import Tile
from ath_cliath.Rect import Rect
from ath_cliath.Map import Map

import ath_cliath.graphics as graphics
import ath_cliath.graveyard as graveyard

def INIT_GAME():
    global smap, leftbar, panel, rightbar

    # Create game surfaces
    smap = pygame.Surface((MAP_WIDTH, MAP_HEIGHT)).convert()
    leftbar = pygame.Surface((LEFTBAR_WIDTH,LEFTBAR_HEIGHT)).convert()
    panel = pygame.Surface((MON_WIDTH,PANEL_HEIGHT)).convert()
    rightbar = pygame.Surface((RIGHTBAR_WIDTH,RIGHTBAR_HEIGHT)).convert()

##########/GRAPHICS MAJ/*##########
def xgraphics():
    global fov_recompute

    if fov_recompute:
        fov_recompute = False
        graphics.render_field_of_view(map, player, 10)

    xrender_smap()
    xrender_leftbar()
    xrender_rightbar()
    xrender_panel()
    pygame.display.update()

def xrender_smap():
    graphics.render_map_background(smap, map)
    for object in objects: 
        if object.blocks == False: object.xdraw()
    for object in objects:
        if object.blocks == True: object.xdraw()
    for object in objects:
        try:
            if object == xy_tile: object.xdraw()
        except:break
    BX, BY, BW, BH = player.x-35, player.y-30, 70, 60
    if player.x < 35: BX = 0
    elif player.x > map.width -35: BX = map.width -70
    if player.y < 30: BY = 0
    elif player.y > map.height -30: BY = map.height -60

    mon.blit(smap, (0+LEFTBAR_WIDTH, 0), (BX*10,BY*10,BW*10,BH*10))
    smap.fill(BACKGROUND_COLOR)
def xrender_leftbar():
    # LEFTBAR PART 1: PLAYER STATS
    pft = player.fighter
    clr_white = (255,255,255)
    clr_other = (0,123,123)
    y, x1, x2 = 10, 50, 150
    textlist=[(player.name.capitalize(), clr_white, LEFTBAR_WIDTH/2, y),
              ('Level:', clr_white, x1, y+30),('Race:', clr_white, x1, y+40),('Class:', clr_white, x1, y+50),
              (str(pft.level), clr_other, x2, y+30),(pft.race, clr_other, x2, y+40),(pft.job, clr_other, x2, y+50),

              ('STR:',clr_white, x1, y+70), ('DEX:',clr_white, x1, y+80), ('CON:',clr_white, x1, y+90), ('MAG:',clr_white, x1, y+100),
              (str(pft.STR), clr_other, x2, y+70),(str(pft.DEX), clr_other, x2, y+80),(str(pft.CON), clr_other, x2, y+90),(str(pft.MAG), clr_other, x2, y+100),

              ('BAB:', clr_white, x1, y+120), ('Attack:', clr_white, x1, y+130), ('Damage:', clr_white, x1, y+140), ('Defense:', clr_white, x1, y+150),
              (str(pft.BAB), clr_other, x2, y+120),(str(pft.get_ab()), clr_other, x2, y+130), (str(pft.get_ac()), clr_other, x2, y+150)]
              
    if pft.get_dmg()[2] > 0: textlist.append(((str(pft.get_dmg()[0])+'-'+str(pft.get_dmg()[1])+'+'+str(pft.get_dmg()[2])), clr_other, x2, y+140))
    elif pft.get_dmg()[2] == 0: textlist.append(((str(pft.get_dmg()[0])+'-'+str(pft.get_dmg()[1])), clr_other, x2, y+140))
    else: textlist.append(((str(pft.get_dmg()[0])+'-'+str(pft.get_dmg()[1])+str(pft.get_dmg()[2])), clr_other, x2, y+140))
    if player.fighter.helm.name != '':
        textlist.append(('- Helm -', clr_other, LEFTBAR_WIDTH/2, y+200))
        textlist.append((player.fighter.helm.name.capitalize(), clr_white, LEFTBAR_WIDTH/2, y+215))
    if player.fighter.armor.name != '':
        textlist.append(('- Armor -', clr_other, LEFTBAR_WIDTH/2, y+230))
        textlist.append((player.fighter.armor.name.capitalize(), clr_white, LEFTBAR_WIDTH/2, y+245))
    if player.fighter.rhand.name != '':
        textlist.append(('- RHand -', clr_other, LEFTBAR_WIDTH/2, y+260))
        textlist.append((player.fighter.rhand.name.capitalize(), clr_white, LEFTBAR_WIDTH/2, y+275))
    if player.fighter.lhand.name != '':
        textlist.append(('- LHand -', clr_other, LEFTBAR_WIDTH/2, y+290))
        textlist.append((player.fighter.lhand.name.capitalize(), clr_white, LEFTBAR_WIDTH/2, y+305))

    for (text, color, x, y) in textlist:
        leftbar.blit((font12.render(text, True, color, BACKGROUND_COLOR)), (x-font12.size(text)[0]/2, y))


    # LEFTBAR PART 2: HP + XP BARS
    bars = [('Health', 340, player.fighter.hp, player.fighter.max_hp, (123, 0, 0), (255, 0, 0)),
            ('XP', 370, player.fighter.xp, player.fighter.level*1000, (123, 0, 123), (255, 0, 255))]
    for bar in bars:
        bar_width = int(float(bar[2]) / bar[3] * LEFTBAR_WIDTH)
        if bar_width > LEFTBAR_WIDTH: bar_width = LEFTBAR_WIDTH
        pygame.draw.rect(leftbar, bar[4], (0, bar[1]+15, LEFTBAR_WIDTH, 10), 0)
        if bar_width > 0:pygame.draw.rect(leftbar, bar[5], (0, bar[1]+15, bar_width, 10), 0)
        leftbar.blit((font12.render(bar[0], True, clr_white)), (LEFTBAR_WIDTH/2-font12.size(bar[0])[0]/2, bar[1]))
        leftbar.blit((font12.render(str(bar[2])+'/'+str(bar[3]), True, clr_white)), (LEFTBAR_WIDTH/2-font12.size((str(bar[2])+'/'+str(bar[3])))[0]/2, bar[1]+13))
    leftbar.blit((font12.render('Dungeon level '+str(dungeon_level),True,clr_white, BACKGROUND_COLOR)),(LEFTBAR_WIDTH/2-font12.size('Dungeon level ')[0]/2,450))

    # LEFTBAR PART 3: BLIT + CLEANUP
    mon.blit(leftbar, (0, 0))
    leftbar.fill(BACKGROUND_COLOR)
def xrender_rightbar():
    itemy, spelly = 3, 30
    clr_white = (255,255,255)
    clr_other = (0,123,123)

    # RIGHTBAR PART 1: DISPLAY ITEMS IN INVENTORY
    rightbar.blit((font12.render(player.name.capitalize()+"'s Inventory", True, clr_white, BACKGROUND_COLOR)), (0,itemy*10))
    itemy += 2
    
    listofi, listofo, listofw, listofW = [], [], [], []
    for object in player.fighter.inventory:
        if object.item.itemtype == 'sword':  listofw.append(object)
        elif object.item.itemtype == 'armor': listofW.append(object)
        elif object.item.itemtype == 'tool':  listofi.append(object)
        else: listofo.append(object)
    printlist = [(listofW, 'Armor'),(listofw, 'Weapons'),(listofi, 'Items'),(listofo, 'Other')]
    for (lst, name) in printlist:
        if lst != []:
            rightbar.blit((font12.render(name, True, clr_other, BACKGROUND_COLOR)), (0,itemy*10))
            for obj in lst: 
                itemy += 1
                rightbar.blit((font12.render(obj.name.capitalize(), True, clr_white, BACKGROUND_COLOR)), (10,itemy*10))
            itemy += 2

    # 2. DISPLAY SPELLS IN SPELLBOOK
    rightbar.blit((font12.render(player.name.capitalize()+"'s Spellbook", True, clr_white, BACKGROUND_COLOR)), (0,spelly*10))
    spelly += 2
    lvl0, lvl1, lvl2, lvl3 = [], [], [], []
    for spell in player.fighter.spellbook:
        if spell[1] == 0:   lvl0.append(spell)
        elif spell[1] == 1: lvl1.append(spell)
        elif spell[1] == 2: lvl2.append(spell)
        elif spell[1] == 3: lvl3.append(spell)
        else: raise ValueError('Unknown spell level in spellbook: '+str(spell[0]))
    sl = player.fighter.spells_left
    spelllist = [(lvl0, 'Level 0', sl[0]), (lvl1, 'Level 1', sl[1]), (lvl2,'Level 2', sl[2]), (lvl3, 'Level 3', sl[3])]
    for (lst, name, sl) in spelllist:
        if lst != []:
            rightbar.blit((font12.render(name+' ('+str(sl)+')', True, clr_other, BACKGROUND_COLOR)), (0,spelly*10))
            for obj in lst: 
                spelly += 1
                rightbar.blit((font12.render(obj[0].capitalize(), True, clr_white, BACKGROUND_COLOR)), (10,spelly*10))
            spelly += 2
    mon.blit(rightbar, (LEFTBAR_WIDTH+700,0))
    rightbar.fill(BACKGROUND_COLOR)
def xrender_panel():
    
    # PANEL 1: RENDER MSG
    y = 0
    for (line, color) in game_msgs:
        panel.blit((font12.render(line, True, color, BACKGROUND_COLOR)), (200, y))
        y += 12
    mon.blit(panel, (0, MON_HEIGHT-PANEL_HEIGHT))
    panel.fill(BACKGROUND_COLOR)
##########*/GRAPHICS MAJ/##########

##########/GRAPHICS MIN/*##########
def x_flushIMG():
    for object in objects:
        object.img = object.name
        if object.fighter:
            if object.fighter.inventory != None:
                for item in object.fighter.inventory:
                    item.img = item.name
            object.fighter.helm.img = object.fighter.helm.name
            object.fighter.armor.img = object.fighter.armor.name
            object.fighter.rhand.img = object.fighter.rhand.name
            object.fighter.lhand.img = object.fighter.lhand.name
def x_loadIMG(status):
    global fov_recompute
    global IMG_STAIRSUP, IMG_PLAYER, IMG_XYTILE
    global IMG_DEAD, IMG_DEAD_LOOT
    fov_recompute = True

    # Images for every level
    IMG_STAIRSUP1 = pygame.image.load('img/stairsup_light.png')
    IMG_STAIRSUP2 = pygame.image.load('img/stairsup_dark.png')
    IMG_STAIRSUP = (IMG_STAIRSUP1, IMG_STAIRSUP2)

    IMG_PLAYER1 = pygame.image.load('img/Ranger.png')
    IMG_PLAYER2 = pygame.transform.flip(IMG_PLAYER1,True, False)
    IMG_PLAYER = (IMG_PLAYER1,IMG_PLAYER2)

    IMG_XYTILE1 = font12.render('X', True, (170,170,0))
    IMG_XYTILE = (IMG_XYTILE1, IMG_XYTILE1)

    IMG_DEAD1 = pygame.image.load('img/dead.png')
    IMG_DEAD2 = pygame.transform.flip(IMG_DEAD1,True,False)
    IMG_DEAD = (IMG_DEAD1,IMG_DEAD2)
    IMG_DEAD_LOOT1 = pygame.image.load('img/dead_loot.png')
    IMG_DEAD_LOOT2 = pygame.transform.flip(IMG_DEAD_LOOT1,True,False)
    IMG_DEAD_LOOT = (IMG_DEAD_LOOT1, IMG_DEAD_LOOT2)
    
    x_loadIMG_spell()

    # Images for specific DLevels
    if 1 <= dungeon_level <= 5:
        # Load image for Tiles + Monsters
        x_loadIMG_dlvl1(status)

    # At last, set player image
    player.img = IMG_PLAYER
def x_loadIMG_dlvl1(status):
    global IMG_FLOOR_DARK, IMG_FLOOR_LIGHT, IMG_WALL_DARK, IMG_WALL_LIGHT
    global IMG_GOBLIN, IMG_KOBOLD_B, IMG_KOBOLD_R, IMG_SNAKE, IMG_BOSS

    # Goblin
    IMG_GOBLIN1 = pygame.image.load('img/lv1/goblin.png')
    IMG_GOBLIN2 = pygame.transform.flip(IMG_GOBLIN1,True,False)
    IMG_GOBLIN = (IMG_GOBLIN1,IMG_GOBLIN2)

    # Kobold Blue
    IMG_KOBOLD_B2 = pygame.image.load('img/lv1/kobold_b.png')
    IMG_KOBOLD_B1 = pygame.transform.flip(IMG_KOBOLD_B2,True,False)
    IMG_KOBOLD_B = (IMG_KOBOLD_B1, IMG_KOBOLD_B2)

    # Kobold Red
    IMG_KOBOLD_R2 = pygame.image.load('img/lv1/kobold_r.png')
    IMG_KOBOLD_R1 = pygame.transform.flip(IMG_KOBOLD_R2,True,False)
    IMG_KOBOLD_R = (IMG_KOBOLD_R1, IMG_KOBOLD_R2)

    # Snake
    IMG_SNAKE2 = pygame.image.load('img/lv1/snake_2.png')
    IMG_SNAKE1 = pygame.transform.flip(IMG_SNAKE2,True,False)
    IMG_SNAKE =  (IMG_SNAKE1, IMG_SNAKE2)

    # Boss 
    IMG_BOSS2 = pygame.image.load('img/lv1/boss.png')
    IMG_BOSS1 = pygame.transform.flip(IMG_BOSS2,True,False)
    IMG_BOSS = (IMG_BOSS1, IMG_BOSS2)        

    # If game is loaded, put back all images that were removed when saving
    if status == 'load':
        for object in objects:
            if object.fighter:
                if object.img == 'goblin': object.img = IMG_GOBLIN
                elif object.img == 'kobold': object.img = IMG_KOBOLD_B
                elif object.img == 'kobold shaman': object.img = IMG_KOBOLD_R
                elif object.img == 'snake': object.img = IMG_SNAKE
            elif object == stairsup: object.img = IMG_STAIRSUP
            elif object.state == 'dead': 
                if object.lootable: object.img = IMG_DEAD_LOOT
                else: object.img = IMG_DEAD
def x_loadIMG_spell():
    global IMG_MAGIC_MISSILE

    IMG_MAGIC_MISSILE = pygame.image.load('img/spell/magic_missile_purple.png')
def x_msgbox(w, h, fill_clr, text, x=None, y=None, fontsize=12):
    if x == None: x = MON_WIDTH/2-w/2
    if y == None: y = y=MON_HEIGHT/2-h/2
    lineclr = (0,0,0)
    window = pygame.Surface((w,h)).convert()
    window.fill(fill_clr)
    pygame.draw.line(window, lineclr,(0,0),(w,0))
    pygame.draw.line(window, lineclr,(0,h-1),(w,h-1))
    pygame.draw.line(window, lineclr,(0,0),(0,h))
    pygame.draw.line(window, lineclr,(w-1,0),(w-1,h-1))
    if fontsize == 12:
        y1 = 10
        window.blit((font12.render(text, True, (123,0,0), (123,123,123))), (w/2-font12.size(text)[0]/2, y1))
    elif fontsize == 15:
        y1 = 10
        window.blit((font15.render(text, True, (123,0,0), (123,123,123))), (w/2-font15.size(text)[0]/2, y1))
    mon.blit(window, (x, y))
    pygame.display.update()

    event = pygame.event.wait()
def x_textbox(w, h, options, fillclr=(123,123,123), lineclr=(0,0,0), x=None, y=None, fontsize=12, surface=None):
    if surface is None: surface = mon
    if x == None: x = MON_WIDTH/2-w/2
    if y == None: y = MON_HEIGHT/2-h/2
    window = pygame.Surface((w,h)).convert()
    window.fill(fillclr)
    pygame.draw.line(window, lineclr,(0,0),(w,0))
    pygame.draw.line(window, lineclr,(0,h-1),(w,h-1))
    pygame.draw.line(window, lineclr,(0,0),(0,h))
    pygame.draw.line(window, lineclr,(w-1,0),(w-1,h-1))
    if fontsize == 12:
        for (text, y1) in options: window.blit((font12.render(text, True, (123,0,0), (123,123,123))), (w/2-font12.size(text)[0]/2, y1))
    elif fontsize == 15:
        for (text, y1) in options: window.blit((font15.render(text, True, (123,0,0), (123,123,123))), (w/2-font15.size(text)[0]/2, y1))
    surface.blit(window, (x, y))
    pygame.display.update()
def x_menu(w, header, options, sorting, fillclr=(123,123,123),lineclr=(127,0,0), x=None, y=None, fontsize=12):
    if sorting == 'a' and len(options) > 26: raise ValueError('26 options exceeded!')
    elif sorting == '1' and len(options) > 9: raise ValueError('9 options exceeded!')
    h = 30+len(options)*12
    if x == None: x = MON_WIDTH/2-w/2
    if y == None: y = MON_HEIGHT/2-h/2
    window = pygame.Surface((w,h)).convert()
    window.fill(fillclr)
    pygame.draw.line(window, lineclr,(0,0),(w,0))
    pygame.draw.line(window, lineclr,(0,h-1),(w,h-1))
    pygame.draw.line(window, lineclr,(0,0),(0,h))
    pygame.draw.line(window, lineclr,(w-1,0),(w-1,h-1))
    letter_index = ord(sorting)
    if sorting == ' ':
        y1 = 10
        window.blit((font12.render(header, True, (123,0,0), fillclr)), (w/2-font12.size(header)[0]/2, 1))
        for (text) in options: 
            y1 += 12
            window.blit((font12.render(text, True, (123,0,0), fillclr)), (w/2-font12.size(text)[0]/2, y1))
            letter_index += 1
    else:
        if fontsize == 12:
            y1 = 10
            window.blit((font12.render(header, True, (123,0,0), fillclr)), (w/2-font12.size(header)[0]/2, 1))
            for (text) in options: 
                y1 += 12
                text = '('+str(unichr(letter_index))+') '+text
                window.blit((font12.render(text, True, (123,0,0), fillclr)), (w/2-font12.size(text)[0]/2, y1))
                letter_index += 1
        elif fontsize == 15:
            y1 = 15
            window.blit((font15.render(header, True, (123,0,0), fillclr)), (w/2-font15.size(header)[0]/2, 1))
            for (text) in options: 
                y1 += 15
                text = '('+str(letter_index)+') '+text
                window.blit((font15.render(text, True, (123,0,0), fillclr)), (w/2-font15.size(text)[0]/2, y1))
                letter_index += 1
    mon.blit(window, (x, y))
    pygame.display.update()

    Done = False
    while not Done:
        event = pygame.event.wait()
        if event.type == pygame.KEYUP:
            Done = True

    event = pygame.event.wait()
    if event.type == pygame.KEYDOWN:
        index = event.key - ord(sorting)
        if 0 <= index < len(options): return index
        return None
def inputbox(title, regex, width=500, height=30):
    inputstring = ''
    window = pygame.Surface((width,height)).convert()
    while 1:
        window.fill((123,123,123))
        pygame.draw.line(window, (0,0,0), (0,0),(0,height-1))
        pygame.draw.line(window, (0,0,0), (width-1,0),(width-1,height-1))
        pygame.draw.line(window, (0,0,0), (0,0),(width-1,0))
        pygame.draw.line(window, (0,0,0), (0,height-1),(width-1,height-1))
        window.blit((font12.render(title, True, (123,0,0), (123,123,123))),(width/2-font12.size(title)[0]/2, 1))
        window.blit((font12.render(inputstring, True, (0,0,0), (123,123,123))),(width/2-font12.size(inputstring)[0]/2, 15))
        mon.blit(window,(MON_WIDTH/2-width/2, MON_HEIGHT/2-height/2))
        pygame.display.update()

        event = pygame.event.wait()
        if event.type == pygame.KEYDOWN:
            key_char = unichr(event.key)
            if event.key == pygame.K_BACKSPACE and inputstring != '':
                inputstring = inputstring[:len(inputstring)-1]
            elif event.key == pygame.K_RETURN: return inputstring
            elif event.key == pygame.K_ESCAPE: return ''
            else:
                key_char = re.search(regex,key_char)
                if key_char != None: inputstring = inputstring + str(key_char.group())
def message(new_msg, color = (255,255,255)):
    (MSG_WIDTH, MSG_HEIGHT) = (60, PANEL_HEIGHT/12)
    new_msg_lines = textwrap.wrap(new_msg, MSG_WIDTH)
    for line in new_msg_lines:
        # If buffer is full, remove the first line
        if len(game_msgs) == MSG_HEIGHT:
            del game_msgs[0]
        # Add new line
        game_msgs.append((line, color))
def x_spell_throw(sourcexy, targetxy, image):
    distance = (math.sqrt((targetxy[0]-sourcexy[0]) ** 2 + (targetxy[1]-sourcexy[1]) ** 2))
    dx, dy = (targetxy[0]-sourcexy[0])/distance, (targetxy[1]-sourcexy[1])/distance


    BX, BY, BW, BH = player.x-35, player.y-30, 70, 60
    if player.x < 35: BX = 0
    elif player.x > map.width -35: BX = map.width -70
    if player.y < 30: BY = 0
    elif player.y > map.height -30: BY = map.height -60


    imgxy = sourcexy
    error_mod = 0.8 # This is added since it would bug otherwise, since INT rounds down
    while imgxy != targetxy:
        if targetxy[0] >= sourcexy[0]: imgx = int(imgxy[0]+dx)
        else: imgx = int(imgxy[0]+dx+error_mod) 
        if targetxy[1] >= sourcexy[1]: imgy =  int(imgxy[1]+dy)
        else: imgy = int(imgxy[1]+dy+error_mod)
        imgxy = (imgx,imgy)
        blitx, blity = (imgx-BX+LEFTBAR_WIDTH)*10,(imgy-BY)*10
        mon.blit(image, (blitx, blity))
        pygame.display.update((blitx, blity, 10, 10))
#        pygame.display.update
#        pygame.event.wait()
        print('X:'+str(imgx*10)+',Y:'+str(imgy*10))

##########*/GRAPHICS MIN/##########
################################
#           CLASSES            #####################################################################################################
################################
class Object:
    def __init__(self, x, y, name, img, blocks, always_visible=False, fighter=None, ai=None, item=None):
        self.x, self.y = x, y
        self.name, self.img, self.blocks, self.always_visible = name, img, blocks, always_visible
        self.fighter, self.ai, self.item = fighter, ai, item
        if self.fighter: self.fighter.owner = self
        if self.ai: self.ai.owner = self
        if self.item: self.item.owner = self
        self.rotation = False
        self.state = 'normal'
    def move(self, dx, dy):
        if not is_blocked(self.x + dx, self.y + dy):
            self.x += dx
            self.y += dy
        if dx < 0: self.rotation = True
        elif dx > 0: self.rotation = False
    def random_move(self):
        x=0; dxy = (dnd_dice (-1, 1),dnd_dice (-1, 1))
        while is_blocked(self.x + dxy[0], self.y + dxy[1]) and x < 20:
            dxy = (dnd_dice (-1, 1),dnd_dice (-1, 1))
            x +=1
        self.move(dxy[0],dxy[1])
    def move_towards(self, target_x, target_y):
        (dx, dy) = (0, 0)
        #do a scan for quickest way to the target
        if distance((self.x+1, self.y+1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+1, self.y+1): (dx, dy) = (1, 1)
        if distance((self.x+1, self.y-1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+1, self.y-1): (dx, dy) = (1, -1)
        if distance((self.x-1, self.y+1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x-1, self.y+1): (dx, dy) = (-1, 1)
        if distance((self.x-1, self.y-1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x-1, self.y-1): (dx, dy) = (-1, -1)
        if distance((self.x+1, self.y+0),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+1, self.y+0): (dx, dy) = (1, 0)
        if distance((self.x+0, self.y+1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+0, self.y+1): (dx, dy) = (0, 1)
        if distance((self.x+0, self.y-1),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x+0, self.y-1): (dx, dy) = (0, -1)
        if distance((self.x-1, self.y+0),(target_x, target_y)) < distance((self.x+dx, self.y+dy),(target_x, target_y)): 
            if not is_blocked(self.x-1, self.y+0): (dx, dy) = (-1, 0)
        self.move(dx, dy)
    def xdraw(self):
        if map[self.x, self.y].in_fov or (self.always_visible and map[self.x, self.y].explored):
            if self == stairsup:
                if map[self.x, self.y].in_fov: smap.blit(self.img[0],(self.x*10,self.y*10))
                else: smap.blit(self.img[1],(self.x*10,self.y*10))
            else:
                try:
                    if not self.rotation: smap.blit(self.img[0], (self.x*10, self.y*10))
                    elif self.rotation: smap.blit(self.img[1], (self.x*10, self.y*10))
                except: print(self.name+' could not be drawn')
class Fighter:
    def __init__(self, hp, STR, DEX, CON, MAG, level,
                 race=None, job=None, BAB=0, death_function=None,
                 inventory=None, spellbook=None, spells_left=[0,0,0,0]):
        # Make all inventory slots empty:
        self.helm, self.armor, self.rhand, self.lhand = AC_empty,AC_empty,AC_empty,AC_empty
        # Assign stats:
        self.hp, self.max_hp = hp, hp
        self.STR, self.DEX, self.CON, self.MAG, self.level = STR, DEX, CON, MAG, level
        self.race, self.job, self.BAB, self.xp, self.death_function = race, job, BAB, 0, death_function
        # Lists:
        self.inventory, self.spellbook, self.spells_left = inventory, spellbook, spells_left
    def attrmod(self, attr):
        if attr == 'STR': return int((self.STR-10)/2)
        elif attr == 'DEX':
            if int((self.DEX-10)/2) > self.armor.item.max_dexmod: return int(self.armor.item.max_dexmod)
            else: return int((self.DEX-10)/2)
        elif attr == 'CON': return int((self.CON-10)/2)
        elif attr == 'MAG': return int((self.MAG-10)/2)
        else: raise ValueError('Strange attribute given!')
    def get_ab(self): 
        dex_ab = self.attrmod('DEX') + self.BAB + self.rhand.item.enchanted
        str_ab = self.attrmod('STR') + self.BAB + self.rhand.item.enchanted
        if self.rhand.item.weight == 'heavy': return str_ab
        elif self.rhand.item.weight == 'light': return dex_ab
        else: 
            if str_ab >= dex_ab: best_ab = str_ab
            else: best_ab = dex_ab
            return best_ab
    def get_ac(self): return int(10+self.armor.item.ac+self.armor.item.enchanted+self.attrmod('DEX'))
    def get_dmg(self): return (self.rhand.item.dmg[0],self.rhand.item.dmg[1],self.attrmod('STR')+self.rhand.item.dmg[2]+self.rhand.item.enchanted) #(min,max,bonus)
    def attack(self, target):
        if self.owner.x > target.x: self.owner.rotation = True
        elif self.owner.x < target.x: self.owner.rotation = False
        attack = melee_dice(self.owner, target) #Will return (1/0, damage), 1=hit, 0=miss
        if attack[0] == 0: message(self.owner.name.capitalize() + ' attacks '+ target.name +' but misses', (255,127,0))
        elif attack[1] <= 0:message(self.owner.name.capitalize() + ' hits '+ target.name +' but did not cause any damage', (225,127,0))
        else:
            message(self.owner.name.capitalize() + ' hits '+ target.name +'!', (225,127,0))
            target.fighter.take_damage(attack[1])
    def cast_spell(self, ID, target=None):
        message('Attempting to cast '+ID[0], MAGIC_COLOR)
        if self.spells_left[ID[1]] == 0: 
            message('You have no level '+str(ID[1])+' spells left', INFO_COLOR)
            return
        else:
            skip_one_turn()
            if game_state == 'dead': return

        if ID[1] == 0:
            if ID[0] == 'ray of frost': spell_cast = spell(ID[0], self.owner, 'select monster')
        elif ID[1] == 1:
            if ID[0] == 'magic missile': spell_cast = spell(ID[0], self.owner, 'select monster')
        else: raise ValueError('Attempted spell not registered in def cast_spells')
#        if ID == 'blink': spell_cast = spell(ID, self.owner, target_xy())

        if spell_cast == 'spell cast': 
            if   ID[1] == 0: self.spells_left = [self.spells_left[0]-1, self.spells_left[1], self.spells_left[2], self.spells_left[3]]
            elif ID[1] == 1: self.spells_left = [self.spells_left[0], self.spells_left[1]-1, self.spells_left[2], self.spells_left[3]]
            elif ID[1] == 2: self.spells_left = [self.spells_left[0], self.spells_left[1], self.spells_left[2]-1, self.spells_left[3]]
            elif ID[1] == 3: self.spells_left = [self.spells_left[0], self.spells_left[1], self.spells_left[2], self.spells_left[3]-1]
    def drop(self, item):
        objects.append(item)
        self.inventory.remove(item)
        item.x, item.y = self.owner.x, self.owner.y
        if self.owner == player: message('You drop ' + item.name, INFO_COLOR2)
    def equip(self, item, weapon_hand='none'): 
        if item.item.equippable == 'helm': 
            self.remove(self.helm)
            self.helm = item
            self.inventory.remove(item)
            if self.owner == player: message("You're now wearing "+item.name)
        elif item.item.equippable == 'armor':
            if self.job == 'mage' and item.item.max_dexmod != 100: message('Mages cannot equip armor', INFO_COLOR)
            else:
                self.remove(self.armor)
                self.armor = item
                self.inventory.remove(item)
                if self.owner == player: message("You're now wearing "+item.name)
        elif item.item.equippable == 'hands': will_add_this()
        elif item.item.equippable == 'hand':
            if weapon_hand == 'right':
                self.remove(self.rhand)
                self.rhand = item
                self.inventory.remove(item)
                if self.owner == player: message("You're now holding "+item.name+' in your right hand')
            elif weapon_hand == 'left':
                self.remove(self.lhand)
                self.lhand = item
                self.inventory.remove(item)
                if self.owner == player: message("You're now holding "+item.name+' in your left hand')
        else: message(item.name + ' cannot be equipped')
    def heal(self, amount):
        self.hp += amount
        if self.hp > self.max_hp: self.hp = self.max_hp
    def remove(self, item_location):
        if item_location == AC_empty: return
        else:
            self.inventory.append(item_location)
            message('Removed '+item_location.name)
        if item_location == self.helm:    self.helm = AC_empty
        elif item_location == self.armor: self.armor = AC_empty
        elif item_location == self.rhand: self.rhand = AC_empty
        elif item_location == self.lhand: self.lhand = AC_empty
    def take_damage(self, damage, attacker=None):
        if damage > 0:
            self.hp -= damage
            if self.hp <= 0:
                if self.death_function is not None: self.death_function(self.owner)
                if self.owner != player:
                    #if attacker == None: player.fighter.xp += (300 + 100*(self.level - player.fighter.level))/4
                    XP = (300 + 100*(self.level - player.fighter.level))/2
                    if XP <= 0: XP = 10
                    if attacker == None: player.fighter.xp += XP
                    else: attacker.fighter.xp += XP
            else:
                if self.owner != player:
                    if self.hp == self.max_hp: message(self.owner.name.capitalize()+' is uninjured',INFO_COLOR)
                    elif self.hp > self.max_hp*9/10: message(self.owner.name.capitalize()+' is barely injured',INFO_COLOR)
                    elif self.hp > self.max_hp/2: message(self.owner.name.capitalize()+' is injured',INFO_COLOR)
                    elif self.hp > self.max_hp/4: message(self.owner.name.capitalize()+' is severly wounded',INFO_COLOR)
                    else: message(self.owner.name.capitalize()+' is almost dead',INFO_COLOR)

class BasicMonster():
    # BasicMonster is basically berserk and will attack and pursure the player no matter what
    def __init__(self, state='normal', chasing_x=None, chasing_y=None):
        self.state = state
        (self.chasing_x, self.chasing_y) = (chasing_x, chasing_y)
    def take_turn(self):
        monster = self.owner
        target = closest_enemy(5, monster)
        if map[monster.x, monster.y].in_fov:
            if target == None: target = player
            (self.chasing_x, self.chasing_y) = (target.x, target.y) #remember where player last was seen
            self.state = 'chasing' #if player has been spotten he will find you
            if distance((monster.x, monster.y),(target.x, target.y)) >= 2: monster.move_towards(target.x, target.y)
            elif target.fighter.hp > 0: monster.fighter.attack(target)
        else: #if cannot see player
            if target != None: 
                (self.chasing_x, self.chasing_y) = (target.x, target.y) #remember where player last was seen
                self.state = 'chasing' #if player has been spotten he will find you
                if distance((monster.x, monster.y), (target.x, target.y)) >= 2: monster.move_towards(target.x, target.y)
                elif target.fighter.hp > 0: monster.fighter.attack(target)
            else:
                if self.state == 'chasing': #if has seen player, move towards last seen point
                    if monster.x == self.chasing_x and monster.y == self.chasing_y: self.state = 'normal'
                    else: monster.move_towards(self.chasing_x, self.chasing_y)
                else: monster.random_move()
class MageMonster():
    # MageMonster will cast spells if in fov, otherwise it will chill since that's what mages do
    def __init__(self): 
        self.prep_spell = None
    def take_turn(self):
        monster = self.owner
        if map[monster.x, monster.y].in_fov:
            target = player
            if self.prep_spell is None:
                self.prep_spell = monster.fighter.spellbook[random.randint(0, len(monster.fighter.spellbook)-1)][0]
                message(monster.name.capitalize()+' is attempting to cast a spell')
            else: 
                spell(self.prep_spell, monster, target)
                self.prep_spell = None
        else: 
            if self.prep_spell != None: self.prep_spell = None
            monster.random_move()

class Item:
    def __init__(self, itemtype, weight, enchanted=0, equippable='no', drops_on_death=False,
                 dmg=(0, 0, 0),
                 ac=0, max_dexmod=100,
                 use_function=None, consumable=(0,0)):
        # itemtype = all, helm, armor, weapon, potion
        # weight = none, light, medium, heavy
        # equippable = all, hand, hands, helm, armor, no
        self.itemtype, self.weight, self.equippable = itemtype, weight, equippable
        self.enchanted, self.drops_on_death = enchanted, drops_on_death
        self.dmg, self.ac, self.max_dexmod = dmg, ac, max_dexmod
        self.use_function, self.consumable = use_function, consumable
    def use(self):
        if self.use_function == None: message ('The ' + self.owner.name + ' cannot be used')
        else: 
            use = item_use(self)
            if use == 'consume': self.consumable = (self.consumable[0], self.consumable[1]-1)
            message (self.owner.name.capitalize()+' has '+str(self.consumable[1])+' charges left', COLOR_WARNING)
            self.owner.name = self.owner.orig_name+' ('+str(self.consumable[1])+')'
    def pick_up(self, looted='no'):
        if len(player.fighter.inventory) >= 26: message('Your inventory is full!')
        else:
            player.fighter.inventory.append(self.owner)
            if looted == 'no': objects.remove(self.owner)
            message ('Picked up ' + self.owner.name, INFO_COLOR2)

################################
#      GAME ENGINE DEFS        #####################################################################################################
################################
def closest_enemy(max_range, owner=None):
    if owner == None: owner = player
    closest_enemy = None
    closest_dist = max_range + 1
    for object in objects:
        if object.fighter and not object == owner and map[object.x, object.y].in_fov and is_enemy(owner, object):
            dist = distance((owner.x, owner.y), (object.x, object.y))
            if dist < closest_dist:
                closest_enemy = object
                closest_dist = dist
    return closest_enemy
def distance(owner_xy, target_xy):
    return math.sqrt((target_xy[0] - owner_xy[0]) ** 2 + (target_xy[1] - owner_xy[1]) ** 2)
def dnd_dice(min, max):
    return random.randint(min, max) 
def is_blocked(x, y):
    if map[x, y].blocked: return True
    for object in objects:
        if object.blocks and object.x == x and object.y == y:
            return True
    return False
def is_enemy(owner, target): 
    if owner == player: 
        if target == player:return False
        else: return True
    else:
        if target == player: return True
        else: return False
def melee_dice(attacker, defender):
    att_AB = attacker.fighter.get_ab()
    dmg = attacker.fighter.get_dmg() 
    damage = random.randint(dmg[0],dmg[1])+dmg[2]
    def_AC = defender.fighter.get_ac()
    """ AB vs AC """
    if att_AB + dnd_dice(1,20) < def_AC: return (0, 0)
    else: return (1, damage)
def random_choice(chances_dict):
    chances = chances_dict.values()
    strings = chances_dict.keys()
    return strings[random_choice_index(chances)]
def random_choice_index(chances):
    dice = dnd_dice(1, sum(chances))
    (running_sum, choice) = (0, 0)
    for w in chances:
        running_sum += w
        if dice <= running_sum: return choice
        choice += 1
def target_xy(focus=None):
    global game_state, xy_tile
    game_state = 'targeting'
    if focus == None: focus = player
    xy_tile = Object(focus.x, focus.y, 'targeting', IMG_XYTILE, False)
    objects.append(xy_tile)
    while 1:
        xgraphics()
        event = pygame.event.wait()
        if event.type == pygame.KEYDOWN:
            xy = (0,0)
            if   event.key == pygame.K_y: xy = (1, -1)
            elif event.key == pygame.K_k: xy = (0, -1)
            elif event.key == pygame.K_y: xy = (-1, -1)
            elif event.key == pygame.K_l: xy = (1, 0)
            elif event.key == pygame.K_h: xy = (-1, 0)
            elif event.key == pygame.K_n: xy = (1, 1)
            elif event.key == pygame.K_j: xy = (0, 1)
            elif event.key == pygame.K_b: xy = (-1, 1)
            (xy_tile.x, xy_tile.y) = (xy_tile.x+xy[0], xy_tile.y+xy[1])
        elif event.key == pygame.K_SPACE:
            (ttile_x, ttile_y) = (xy_tile.x, xy_tile.y)
            objects.remove(xy_tile)
            game_state = 'playing'
            return (ttile_x, ttile_y)
        elif event.key == pygame.K_ESCAPE:
            objects.remove(xy_tile)
            game_state = 'playing'
            return 'cancelled'

################################
#     TRIGGERS AND ACTIONS     #####################################################################################################
################################
def check_level_up():
    if player.fighter.xp >= player.fighter.level*1000:
        player.fighter.xp -= player.fighter.level*1000
        player.fighter.level += 1
        message('You reached level ' + str(player.fighter.level) + '!', (0,255,0))
        if player.fighter.level > 10: raise ValueError('Level up is not working for level > 10')

        # Add hp and bab
        if player.fighter.job == 'fighter':
            player.fighter.hp_base += dnd_dice(1,8)
            player.fighter.BAB += 1
        elif player.fighter.job == 'rogue':
            rogue_bab_levels=[2, 3, 4, 6, 7, 8, 10]
            player.fighter.hp_base += dnd_dice(1,6)
            if player.fighter.level in rogue_bab_levels: player.fighter.BAB += 1
        elif player.fighter.job == 'mage':
            mage_bab_levels=[2, 4, 6, 8, 10]
            player.fighter.hp_base += dnd_dice(1,4)
            if player.fighter.level in mage_bab_levels: player.fighter.BAB += 1
        else: raise ValueError('Player class not defined')

        # Add ability
        choice = None
        while choice == None:
            choice = x_menu(300,'Level up! Choose a stat to raise',
                          ['+1 Strength, currently ' + str(player.fighter.STR),
                           '+1 Dexterity, currently ' + str(player.fighter.DEX),
                           '+1 Constitution, currently ' + str(player.fighter.CON),
                           '+1 Magic, currently ' + str(player.fighter.MAG)],'a',lineclr=(127,0,0))
        if   choice == 0: player.fighter.STR += 1
        elif choice == 1: player.fighter.DEX += 1
        elif choice == 2: player.fighter.CON += 1
        elif choice == 3: player.fighter.MAG += 1

        #Cleaning up. Setting all static info
        player.fighter.max_hp = player.fighter.hp_base + int(((player.fighter.CON -10)/2)*player.fighter.level)

##########/SPELLS/*##########
def spell(spell, caster, target): # Target is either Object or (x, y)
    if caster == player:
        if target == 'select monster':
            target = None
            enemy = closest_enemy(15)
            if enemy == None: enemy = player
            xy = target_xy(enemy)
            if xy == 'cancelled': return 'cancelled'
            else:
                (x, y) = xy
                for object in objects:
                    if object.x == x and object.y == y and object.fighter and object != caster:
                        target = object
                        break
                if target == None: return 'cancelled'

    if target != None:
        if spell == 'magic missile': spell_1_magic_missile(caster, target)
        elif spell == 'ray of frost': spell_0_ray_of_frost(caster, target)
        return 'spell cast'
def spell_0_ray_of_frost(caster, target):
    dmg = dnd_dice(1,4) + 1
    message('Ray of frost hits ' + target.name, MAGIC_COLOR)
    target.fighter.take_damage(dmg)
def spell_1_magic_missile(caster, target):
    dmg = 0
    for no in range(int((caster.fighter.level+1)/2)): dmg += dnd_dice(1,4) + 1 # 1 missile +1 per 2 levels
#    x_spell_throw((caster.x,caster.y),(target.x,target.y), IMG_MAGIC_MISSILE)
    message('Magic missiles hit ' + target.name, MAGIC_COLOR)
    target.fighter.take_damage(dmg)
##########*/SPELLS/##########

##########/SPAWN/*##########
def spawn_monster(monster_id, x, y):
    monster_inventory = []
    mvp = BasicMonster()
    (w_enchanted, a_enchanted) = (dnd_dice(1, 10), dnd_dice(1, 10))
    if w_enchanted > 1: w_enchanted = 0
    if a_enchanted > 1: a_enchanted = 0
    if 1 <= dungeon_level <= 5:
        if monster_id == 'goblin':
            fighter_component = Fighter(hp=4, STR=8, DEX=10, CON=10, MAG=0,level=1,BAB=1, death_function=monster_death, inventory=[])
            monster = Object(x, y, 'goblin', IMG_GOBLIN, True, fighter=fighter_component, ai=mvp)
            monster.fighter.rhand = spawn_item('AC_w_shortsword')
        elif monster_id == 'kobold':
            fighter_component = Fighter(hp=2, STR=6, DEX=12, CON=10, MAG=0,level=1,BAB=1, death_function=monster_death,inventory=[])
            monster = Object(x, y, 'kobold', IMG_KOBOLD_B, True, fighter=fighter_component, ai=mvp)
            monster.fighter.armor = spawn_item('AC_a_leatherarmor')
            monster.fighter.rhand = spawn_item('AC_w_shortsword')
        elif monster_id == 'kobold shaman':
            fighter_component = Fighter(hp=10, STR=6, DEX=12, CON=10, MAG=0,level=2,BAB=0, death_function=monster_death,inventory=[], spellbook=[])
            monster = Object(x, y, 'kobold shaman', IMG_KOBOLD_R, True, fighter=fighter_component, ai=MageMonster())
            monster.fighter.rhand = spawn_item('AC_w_dagger')
            monster.fighter.spellbook.append(('ray of frost', 0))
            monster.fighter.spellbook.append(('magic missile', 1))
        elif monster_id == 'snake':
            fighter_component = Fighter(hp=4, STR=6, DEX=17, CON=10, MAG=0,level=1,BAB=0, death_function=monster_death,inventory=[])
            monster = Object(x, y, 'snake', IMG_SNAKE, True, fighter=fighter_component, ai=mvp)
    objects.append(monster)
def spawn_item(name, enchanted=0):
    ##### ARMOR #####
    # Light
    if name == 'AC_a_cloak': returned_item = Object(0, 0, 'cloak', 'IMG_A_CLOAK', False, item=Item(
            itemtype='armor', weight='light', equippable='armor', ac=2, max_dexmod=100))
    # Medium
    elif name == 'AC_a_leatherarmor': returned_item = Object(0, 0, 'leather armor', 'IMG_A_LEATHERARMOR', False, item=Item(
            itemtype='armor', weight='medium', equippable='armor', ac=4, max_dexmod=8))
    # Heavy
    elif name == 'AC_a_chainmail': returned_item = Object(0, 0, 'chainmail', 'IMG_A_CHAINMAIL', False, item=Item(
            itemtype='armor', weight='medium', equippable='armor', ac=6, max_dexmod=4))
    ##### TOOLS #####
    elif name == 'AC_i_magicmarker': returned_item = Object(0, 0, 'magic marker', 'IMG_I_MAGICMARKER', False, item=Item(
            itemtype='tool', weight='light', drops_on_death=True, use_function='yes', consumable=(1,5)))
    elif name == 'AC_i_digging': returned_item = Object(0, 0, 'wand of digging', 'IMG_I_DIGGING', False, item=Item(
            itemtype='tool', weight='light', drops_on_death=True, use_function='yes', consumable=(1,dnd_dice(1,5))))
    ##### WEAPONS #####
    # Light
    elif name == 'AC_w_dagger': returned_item = Object(0, 0, 'dagger', 'IMG_W_DAGGER', False, item=Item(
            itemtype='sword', weight='light', equippable='hand', dmg=(1,4,0)))
    # Medium
    elif name == 'AC_w_shortsword': returned_item = Object(0, 0, 'shortsword', 'IMG_W_SHORTSWORD', False, item=Item(
            itemtype='sword', weight='medium', equippable='hand', dmg=(1,6,0)))
    # Heavy
    elif name == 'AC_w_longsword': returned_item = Object(0, 0, 'longsword', 'IMG_W_LONGSWORD', False, item=Item(
            itemtype='sword', weight='heavy', equippable='hand', dmg=(1,8,0)))
    elif name == 'AC_w_greatsword': returned_item = Object(0, 0, 'greatsword', 'IMG_W_GREATSWORD', False, item=Item(
            itemtype='sword', weight='heavy', equippable='hands', dmg=(1,11,1)))
    else: raise ValueError('Requested item ('+str(name)+') does not exist in def spawn_item')
    ##### FINISH #####
    if dnd_dice(1,20) == 1: returned_item.item.drops_on_death = True
    if enchanted > 0: 
        returned_item.item.enchanted = enchanted
        returned_item.name = returned_item.name+' +'+str(returned_item.item.enchanted)
        returned_item.item.drops_on_death = True
    return returned_item
##########*/SPAWN/##########

##########/PLAYER/*##########
def player_action_wait():
    global waiting_turns, game_state
    if waiting_turns == 0: # Rest is done
        player.fighter.hp = player.fighter.max_hp
        player_reset_spells()
        message('You feel refreshed')
        game_state = 'playing'
    else: 
        waiting_turns -= 1
        for object in objects: # Rest Aborted
            if object.ai and object != player and map[object.x, object.y].in_fov:
                message(object.name.capitalize() + ' in sight!')
                game_state = 'playing'
def player_action_drop():
    index = None
    if len(player.fighter.inventory) == 0: 
        message('You have no item to drop', INFO_COLOR)
        return 'cancelled'
    else:
        options = [item.name for item in player.fighter.inventory]
        if len(options) > 0: index = x_menu(400, 'Which item do you want to drop?', options, 'a')
        else: message('You have no item to drop')
        if index != None:
            optlist = [item for item in player.fighter.inventory]
            player.fighter.drop(optlist[index])
        else: return 'cancelled'
def player_action_equip():
    index = None
    if len(player.fighter.inventory) == 0: 
        message('You have no armor to equip', INFO_COLOR)
        return 'cancelled'
    else:
        options = [item.name for item in player.fighter.inventory if item.item.equippable == 'armor']
        if len(options) > 0: index = x_menu(400, 'What do you want to equip?', options, 'a')
        else: message('You have no armor to equip', INFO_COLOR)
        if index != None:
            optlist = [item for item in player.fighter.inventory if item.item.equippable == 'armor']
            player.fighter.equip(optlist[index])
        else: return 'cancelled'
def player_action_remove():
    index = None
    choice = x_menu(400, 'Which item do you want to remove?',
                    ['Helm:' + player.fighter.helm.name,
                     'Armor:' + player.fighter.armor.name,
                     'R Hand:' + player.fighter.rhand.name,
                     'L Hand:' + player.fighter.lhand.name], 'a')
    if choice == 0 and player.fighter.helm.name != '': player.fighter.remove(player.fighter.helm)
    elif choice == 1 and player.fighter.armor.name != '': player.fighter.remove(player.fighter.armor)
    elif choice == 2 and player.fighter.rhand.name != '': player.fighter.remove(player.fighter.rhand)
    elif choice == 3 and player.fighter.lhand.name != '': player.fighter.remove(player.fighter.lhand)
def player_action_use():
    index = None
    options = [item.name for item in player.fighter.inventory if item.item.itemtype == 'tool']
    if len(options) > 0: index = x_menu(400, 'Which item do you want to use?', options, 'a')
    else: 
        message('You have no item to use', INFO_COLOR)
        return 'cancelled'
    if index != None:
        optlist = [item for item in player.fighter.inventory if item.item.itemtype == 'tool']
        optlist[index].item.use()
    else: return 'cancelled'
def player_action_wield():
    index = None
    if len(player.fighter.inventory) == 0: 
        message('Your inventory is empty')
        return 'cancelled'
    else:
        options = [item.name for item in player.fighter.inventory if item.item.equippable == 'hand']
        if len(options) > 0: index = x_menu(400, 'What do you want to wield?', options, 'a')
        else: message('You have no weapon to wield', INFO_COLOR)
        if index != None:
            optlist = [item for item in player.fighter.inventory if item.item.equippable == 'hand']
            hand = x_menu(400, 'In which hand do you want to equip it?',
                          ['Right hand','Left hand'],'a')
            if hand == 0:   w_hand='right'
            elif hand == 1: w_hand='left'
            if hand != None: player.fighter.equip(optlist[index], w_hand)
        else: return 'cancelled'
def player_move_or_attack(dx, dy):
    global fov_recompute
    x = player.x + dx; y = player.y + dy #Check what is there and grep it
    target = None
    for object in objects:
        if object.fighter and object.x == x and object.y == y:
            target = object
            break
    if target != None and target != player: player.fighter.attack(target)
    else:
        player.move(dx, dy)
        fov_recompute = True
def player_reset_spells():
    if player.fighter.job == 'mage':
        MAGmod = int((player.fighter.MAG-10)/2)
        if MAGmod < 0 : player.fighter.spells_left = [0, 0, 0, 0]
        else:
            # Adding base spells per level
            lvl = player.fighter.level
            if lvl == 1:   player.fighter.spells_left = [6, 3, 0, 0]
            elif lvl == 2: player.fighter.spells_left = [6, 4, 0, 0]
            elif lvl == 3: player.fighter.spells_left = [6, 5, 0, 0]
            elif lvl == 4: player.fighter.spells_left = [6, 6, 3, 0]
            elif lvl == 5: player.fighter.spells_left = [6, 6, 4, 0]
            elif lvl == 6: player.fighter.spells_left = [6, 6, 5, 3]
            elif lvl == 7: player.fighter.spells_left = [6, 6, 6, 4]
            elif lvl == 8: player.fighter.spells_left = [6, 6, 6, 5]
            elif lvl == 9: player.fighter.spells_left = [6, 6, 6, 6]
            else: raise ValueError('Level 10+ not added to player_reset_spells()')
            # Adding bonus from MAGmod
            if MAGmod >= 1: player.fighter.spells_left[1] += 1
            if MAGmod >= 2: player.fighter.spells_left[2] += 1
            if MAGmod >= 3: player.fighter.spells_left[3] += 1
            if MAGmod >= 5: raise ValueError('Fix MAGmod to spells for MAGmod 5+')
def player_spell_menu():
    index = None
    options = [spell[0] for spell in player.fighter.spellbook]
    if len(options) > 0: index = x_menu(300,'Which spell do you want to cast?', options, 'a',lineclr=(127,0,0))
    else: 
        message('You know no spells')
        return 'cancelled'
    if index != None:
        options = [spell for spell in player.fighter.spellbook]
        player.fighter.cast_spell(options[index])
    else: return 'cancelled'
##########*/PLAYER/##########

def skip_one_turn():
    take_turn_ai()
    xgraphics()
def next_level():
    global dungeon_level, game_state, fov_recompute
    dungeon_level += 1

    if 1 <= dungeon_level <= 5:
        message('You ascend to the next level', (0,123,0))
        make_map_test()
        fov_recompute = True
    else: 
        player.dlevel = '5+'
        message('You have escaped the dungeon!', (0,255,0))
        message('Press escape to leave')
        game_state = 'dead'
        graveyard.save(player)
def new_player(player_name, player_job):
    global player
    # 1. Statics
    player_component = Fighter(hp=0, STR=10, DEX=10, CON=10, MAG=10, level=1, race='human', job=player_job, BAB=0, 
                               death_function=player_death, inventory = [], spellbook = [])
    player = Object(0, 0, player_name, 0, blocks=True, fighter=player_component)

    # 2. Player jobs
    if player_job == 'rogue':
        player.fighter.DEX = 14
        player.fighter.hp_base = 6
        player.fighter.armor, player.fighter.rhand = spawn_item('AC_a_leatherarmor'), spawn_item('AC_w_shortsword')
    elif player_job == 'fighter':
        player.fighter.STR = 14
        player.fighter.hp_base = 8
        player.fighter.bab = 1
        player.fighter.armor, player.fighter.rhand = spawn_item('AC_a_chainmail'), spawn_item('AC_w_longsword')
    elif player_job == 'mage':
        player.fighter.STR, player.fighter.DEX, player.fighter.MAG = 8, 8, 14
        player.fighter.hp_base = 4
        player.fighter.armor = spawn_item('AC_a_cloak')
        player.fighter.spellbook.append(('ray of frost', 0))
        player.fighter.spellbook.append(('magic missile', 1))
        player.fighter.spells_left = [6, 3, 0, 0]

    # 3. Set HP/MP and return
    player.fighter.hp = player.fighter.hp_base + int((player.fighter.CON -10)/2)
    player.fighter.max_hp = player.fighter.hp
def from_dungeon_level(table):
    #returns a value that depends on level. the table specifies what value occurs after each level, default is 0.
    for (value, level) in reversed(table):
        if dungeon_level >= level:
            return value
    return 0
def place_objects(room):
 
    # Item and monster chance
    if 1 <= dungeon_level <= 5:
        monster_chances = {}
        monster_chances['goblin'] = 40
        monster_chances['kobold'] = 40
        monster_chances['snake'] = 20
        monster_chances['kobold shaman'] = from_dungeon_level([[10,1], [20,2]])
        max_monsters_per_room = from_dungeon_level([[2, 1], [3, 3], [4, 5]])

    # Place stuff
    for i in range(random.randint(0,max_monsters_per_room)):
        x = random.randint(room.x1+1, room.x2-1)
        y = random.randint(room.y1+1, room.y2-1)
        if not is_blocked(x, y):
            choice = random_choice(monster_chances)
            spawn_monster(choice, x, y)
def make_map_test():
    global map, objects, stairsup
    objects, rooms, num_rooms = [player], [], 0
    MAX_ROOMS,ROOM_SIZE = 50, (6, 10)

    map = Map(MAP_WIDTH/10, MAP_HEIGHT/10)

    for r in range(MAX_ROOMS):
        w, h = random.randint(ROOM_SIZE[0], ROOM_SIZE[1]), random.randint(ROOM_SIZE[0], ROOM_SIZE[1])
        x, y = random.randint(1, map.width -w), random.randint(1, map.height -h -1)
        new_room = Rect(x, y, w, h)

        failed = False
        for other_room in rooms:
            if new_room.intersect(other_room):
                failed = True
                break
        if not failed:
            map.create_room(new_room)
            (new_x, new_y) = new_room.center() #center coordinates of new room, will be useful later
            if num_rooms == 0: #this is the first room, where the player starts at
                player.x = new_x
                player.y = new_y
            else: #all rooms after the first:
                place_objects(new_room)
                #connect it to the previous room with a tunnel
                (prev_x, prev_y) = rooms[num_rooms-1].center()
                if random.randint(0, 1) == 1: #First move horizontally, then vertically
                    map.create_horizontal_tunnel(prev_x, new_x, prev_y)
                    map.create_vertical_tunnel(prev_y, new_y, new_x)
                else: #first move vertically, then horizontally
                    map.create_vertical_tunnel(prev_y, new_y, prev_x)
                    map.create_horizontal_tunnel(prev_x, new_x, new_y)
            rooms.append(new_room)
            num_rooms += 1
    
    stairsup = Object(new_x, new_y, 'stairs going up', IMG_STAIRSUP, False, always_visible=True)
    objects.append(stairsup)

######### Key-pressing commands #########
def player_death(player):
    global game_state
    message('You have died!', (127,0,0))
    game_state = 'dead'
    player.img = IMG_DEAD
    player.dlevel = dungeon_level
    graveyard.save(player)
def monster_death(monster):
    message(monster.name.capitalize() + ' was slain', (127,0,0))
    monster.img = IMG_DEAD
    monster.blocks = False
    monster.ai = None
    monster.name = monster.name + ' corpse'
    monster.state = 'dead'
    #Drop all held items and put into inventory
    eq = [monster.fighter.helm, monster.fighter.armor, monster.fighter.rhand, monster.fighter.lhand]
    for item in eq:
        if item.item.drops_on_death:
            monster.fighter.inventory.append(item)
    if len(monster.fighter.inventory) != 0:
        monster.loot = monster.fighter.inventory
        monster.lootable = True
    else: monster.lootable = False
    monster.fighter = None

##############################
#   ALL 'ACTION' COMMANDS    #####################################################################################################
##############################
def take_turn_ai():
    for object in objects:
        if object.ai:
            object.ai.take_turn()
def take_turn_player():
    global fov_recompute, game_state, waiting_turns
    if game_state == 'waiting': event = pygame.event.poll() # Check for keypress
    else: event = pygame.event.wait() # Wait for keypress
    
#    pygame.event.clear() ## Removed this, should be OK

    if event.type == pygame.KEYDOWN:

        """ GENERAL COMMANDS (DESPITE PLAYING / DEAD) """
        if event.key == pygame.K_ESCAPE:
            if game_state == 'waiting': game_state = 'playing'
            choice = x_menu(300, 'Do you wish to save and return to menu?', ['Yes', 'No'], '1')
            if choice == 0:
                save_game()
                return 'break'
            else: return 'didnt_take_turn'


        """ COMMANDS DURING PLAY """
        if game_state == 'playing': 
            act = None
                
            """KP_KEYS = MOVEMENT """
            if   event.key == pygame.K_u: player_move_or_attack(1, -1)
            elif event.key == pygame.K_k: player_move_or_attack(0, -1)
            elif event.key == pygame.K_y: player_move_or_attack(-1, -1)
            elif event.key == pygame.K_l: player_move_or_attack(1, 0)
            elif event.key == pygame.K_h: player_move_or_attack(-1, 0)
            elif event.key == pygame.K_n: player_move_or_attack(1, 1)
            elif event.key == pygame.K_j: player_move_or_attack(0, 1)
            elif event.key == pygame.K_b: player_move_or_attack(-1, 1)

            #""" A-Z """
            elif event.key == pygame.K_r: act = player_action_remove()
            elif event.key == pygame.K_d: act = player_action_drop()
            elif event.key == pygame.K_u: act = player_action_use()
            elif event.key == pygame.K_w: act = player_action_wield()
            elif event.key == pygame.K_e: act = player_action_equip()
            elif event.key == pygame.K_z: act = player_spell_menu()

            #""" SPECIAL CHARACTERS """
            elif event.key == pygame.K_SPACE:
                rest = x_menu(400, 'Do you wish to rest?',['Yes','No'],'1')
                if rest == 0:   
                    game_state = 'waiting'
                    waiting_turns = 10
                    message('Resting..')
            elif event.key == pygame.K_LESS:
                if stairsup.x == player.x and stairsup.y == player.y: next_level()
            elif event.key == pygame.K_COMMA:
                for object in objects:
                    if object.x == player.x and object.y == player.y and object.item:
                        object.item.pick_up()
                        break

            else: return 'didnt_take_turn'
            if act == 'cancelled': return 'didnt_take_turn'
    else: return 'didnt_take_turn'
################################
#     MAIN GAME MODES HERE     #####################################################################################################
################################
def view_graveyard():
    try:
        characters = graveyard.load(25)
    except:
        return x_msgbox(300,30, (123,123,123), 'Unable to load graveyard')

    objects = [' No Name                 CLvl DLvl Class']
    for i, char in enumerate(characters, 1):
        objects.append("%2d %s%s%2d   %2d  %s" % 
                (i, char[0], ' ' * (24 - len(char[0])),
                 char[1], char[2], char[3]))
    x_menu(400, 'Graveyard', objects,' ', lineclr=(0,0,0))

def save_game():
    #open a new empty shelve (possibly overwriting an old one) to write the game data
    x_flushIMG()

    if game_state == 'dead':
        if os.path.isfile('save/'+player.name): os.remove('save/'+player.name)
    else:
        file = shelve.open('save/'+player.name, 'n')
        file['map'] = map
        file['objects'] = objects
        file['player_index'] = objects.index(player)  #index of player in objects list
        file['game_msgs'] = game_msgs
        file['game_state'] = game_state
        file['dungeon_level'] = dungeon_level
        file['stairs_index'] = objects.index(stairsup)
        file.close()
def load_game():
    #open the previously saved shelve and load the game data
    global map, objects, player, game_msgs, game_state, stairsup, dungeon_level
    options = [game for game in os.listdir('save/') if game[0] != '.']
    if len(options) == 0: x_msgbox(300,30, (123,123,123), 'No savegames exist!')
    else: 
        index = x_menu(300,'Select savegame', options,'a')
        if index == None: return
        else:
            savegame = options[index]
            # Shelve'it!
            file = shelve.open('save/'+str(savegame), 'r')
            map = file['map']
            objects = file['objects']
            player = objects[file['player_index']]
            game_msgs = file['game_msgs']
            game_state = file['game_state']
            dungeon_level = file['dungeon_level']
            stairsup = objects[file['stairs_index']]
            file.close()

            x_loadIMG('load')
            return True
def main_menu():
    IMG_MAIN_MENU = pygame.image.load('img/BG_IMG2.png')
    while 1: # Main Loop
        # TOP
        con.blit(IMG_MAIN_MENU,(0,0))
        con.blit((font20.render('Ath Cliath', True, (123,0,0))), (MON_WIDTH/2-font20.size('Ath Cliath')[0]/2, MON_HEIGHT/2-150))

        # MID
        printlist = [('(L) Load Game', 35),('(N) New game', 15),('(Q) Quit', 175),('(G) Graveyard', 155)]
        x_textbox(200, 200, printlist, y=300, fontsize=15, surface=con)

        # LOW
        printlist = [(version, 10),('A python roguelike', 25),('Created by Olle Kvarnstrom', 40)]
        x_textbox(200, 60, printlist, y=650, surface=con)
        mon.blit(con, (0,0))
        pygame.display.update()

        # KEYPRESS
        event = pygame.event.wait()
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_l: # Load Game
                loadgame_ok = load_game()
                if loadgame_ok: play_game()
            elif event.key == pygame.K_n: # New Game
                newgame_ok = new_game()
                if newgame_ok: play_game()
            elif event.key == pygame.K_q: # Quit game
                break
            elif event.key == pygame.K_g: # Graveyard
                view_graveyard()
                

def new_game(testing=False):
    global game_msgs, game_state, dungeon_level

    # 1. Player Name
    if testing: player_name = 'test'
    else: player_name = inputbox('Player name?','[a-zA-Z]+', width=300).capitalize()
    if player_name == '': return False

    # 2. Player Job
    index = None
    while index == None:
        index = x_menu(200, 'Which class are you?', ['Fighter','Mage'],'1', y=350,lineclr=(0,0,0))
    if   index == 0: player_job = 'fighter'
    elif index == 1: player_job = 'mage'
    else: raise ValueError('No player_job chosen')

    # 3. Start
    new_player(player_name, player_job)
    dungeon_level = 1
    x_loadIMG('new')
    make_map_test()
    #make_map_cave()
    game_state = 'playing'
    game_msgs = []
    return True
def play_game():
    global turn
    player_action = None

    while 1:

        check_level_up()
        xgraphics()
        if (game_state == 'playing' and player_action != 'didnt_take_turn') or game_state == 'waiting': 
            take_turn_ai()
        player_action = take_turn_player()
        if player_action == 'break': break
        if game_state == 'waiting': player_action_wait()
        #print('turn: '+str(turn))
        turn += 1

if __name__ == "__main__":
    # Surface sizes:
    MON_WIDTH, MON_HEIGHT = 1360, 760
    MAP_WIDTH, MAP_HEIGHT = 1000, 1000 
    LEFTBAR_WIDTH, LEFTBAR_HEIGHT = 200, MON_HEIGHT 
    PANEL_WIDTH, PANEL_HEIGHT =     MON_WIDTH, 160
    RIGHTBAR_WIDTH, RIGHTBAR_HEIGHT=MON_WIDTH-LEFTBAR_WIDTH-700,MON_HEIGHT-PANEL_HEIGHT

    # Predef colors:
    BACKGROUND_COLOR = (0, 0, 0)
    INFO_COLOR = (100,100,100)
    INFO_COLOR2 = (200,200,200)
    MAGIC_COLOR = (0,255,255)

    # Init pygame, font and caption and main surfaces
    pygame.init()
    if pygame.font: 
        font12 = pygame.font.SysFont('monospace',12, bold=True)
        font15 = pygame.font.SysFont('monospace',15, bold=True)
        font20 = pygame.font.SysFont('monospace',20, bold=True)
    pygame.display.set_caption('Ath Cliath')
    mon = pygame.display.set_mode((MON_WIDTH, MON_HEIGHT)) 
    con = pygame.Surface((MON_WIDTH, MON_HEIGHT))

    # List of Defines
    AC_empty = Object(0, 0, '', None, True, item=Item(itemtype='all', weight='none', equippable='all', dmg = (1,2,0), ac=0, max_dexmod=100))
    version = 'v0.3.0c'
    turn = 0

    INIT_GAME()
    main_menu()
